package main

/*
Go позволяет отложить вызов внутренней функции до завершения функции внешней.
Делается это с помощью ключевого слова defer перед вызовом функции.
Отложенные функции выполняюся в обратном порядке (LIFO):

	func ExampleDefer1() {
		defer func() { fmt.Println(1) }()
		defer func() { fmt.Println(2) }()
		defer func() { fmt.Println(3) }()
		// Output:
		// 3
		// 2
		// 1
	}

С помощью отложенного вызова часто закрываются файлы и соединения,
а также осуществляется обработка паники в работе функции,
при этом используются возможности анонимных функций.

Как вы знаете, возбуждение аварии осуществляется вызовом функции panic(),
которой в качестве аргумента передается любой требуемый объект.
Восстановление же после аварии осуществляется вызовом функции recover(),
возвращающей переданный функции panic() аргумент.
При этом функция recover() может быть обработана,
если ее вызов отложен до возникновения аварии:

	func someFuncWithPanic() (err error) {
		defer func() {
			// отложенный вызов анонимной функции, проверяющей, что работа функции завершена
			// без ошибок. Если функция recover() возвращает что угодно кроме nil, значит в ходе
			// выполнения функции возникла паника.
			if e := recover(); e != nil {
				// Здесь происходит приведение интерфейса. Результат приведения присваивается
				// переменной err типа error, которая уже объявлена при самом вызове функции
				// someFuncWithPanic.
				err = e.(error)
				// после этого анонимная функция завершает свою работу, паника обработана,
				// переменная err, в которой содержится информации о возникшей панике,
				// возвращается как результат выполнения функции.
			}
		}()
		panic(errors.New("fatal error"))
	}
	func ExamplePanicRecover() {
		if err := someFuncWithPanic(); err != nil {
			fmt.Println(err)
		}
		// Output:
		// fatal error
	}
*/
func main() {

}
