package main

import (
	"fmt"
	"sync"
)

/*
Несмотря на то, что в каждой горутине значение counter сбрасывается к 0,
а затем увеличивается до 5, мы видим, что несколько горутин после сброса
переменной работают совсем с другим значением. То есть при запуске
горутин каждая из них получает значение переменной counter и начинает с
ней работать. Пока одна горутина еще не закончила работу с counter в цикле,
с этой же переменной начинает работать и другая горутина. То есть к одному
и тому же разделяемому общему ресурсу - переменной counter одновременно
работают сразу несколько горутин. Это может привести к некорректным
результатам.

С помощью мьютексов можно ограничить доступ к переменной таким образом,
чтобы только одна горутина имела к ней монопольный доступ в один момент
времени.
*/

var counter int = 0 //  общий ресурс
func main() {

	ch := make(chan bool) // канал
	for i := 1; i < 5; i++ {
		go work1(i, ch)
	}
	// ожидаем завершения всех горутин
	for i := 1; i < 5; i++ {
		<-ch
	}
	fmt.Println("The End")

	var mutex sync.Mutex
	for i := 1; i < 5; i++ {
		go work2(i, ch, &mutex)
	}

	for i := 1; i < 5; i++ {
		<-ch
	}

	fmt.Println("The End")
}
func work1(number int, ch chan bool) {
	counter = 0
	for k := 1; k <= 5; k++ {
		counter++
		fmt.Println("Goroutine", number, "-", counter)
	}
	ch <- true
}

/*
С помощью вызова mutex.Lock() мьютекс блокируется данной горутиной.
Это значит, что к последующему коду имеет доступ только та горутина,
которая первая заблокировала мьютекс. Остальные горутины ждут пока,
мьютекс освободится.

Далее горутина сбрасывает значение переменной counter к нулю и затем
в цикле последовательно увеличивает его. В конце, когда все действия
с общим ресурсом уже выполнены, горутина освобождает мьютекс с помощью
вызова mutex.Unlock(). Ожидающие горутины получают сигнал, что мьютекс
освободился, и одна из горутин блокирует мьютекс и начинает выполнять
действия с переменной counter. И так далее горутины последовательно
захватывают и освобождают мьютекс.
*/

func work2(number int, ch chan bool, mutex *sync.Mutex) {
	mutex.Lock() // блокируем доступ к переменной counter
	counter = 0
	for k := 1; k <= 5; k++ {
		counter++
		fmt.Println("Goroutine", number, "-", counter)
	}
	mutex.Unlock() // деблокируем доступ
	ch <- true
}
