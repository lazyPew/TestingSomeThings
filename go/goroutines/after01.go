package main

import (
	"fmt"
	"math/rand"
	"time"
)

/*
Часто нам нужно подождать два или более значения разных типов.
Одним из примеров этого является случай ожидания некоторых
значений по каналу, но ждать слишком долго нельзя. Возможно,
мы немного нетерпеливы по отношению к сонным гоферам, и
терпение это не вечно. Или нам еще может потребоваться
установить тайм-аут сетевого запроса после несколько секунд,
а не несколько минут.
К счастью стандартная библиотека Go предоставляет полезную
функцию time.After, которая может нам значительно помочь.
Она возвращает канал, который получает значение по прошествии
некоторого времени (горутина, что отправляет значение, является
частью среды выполнения Go).

Нам нужно продолжать получать значения от сонных гоферов, пока
они не закончат спать, или у нас не кончится терпение. Это
означает, что нам нужно одновременно ждать таймера одного и
другого канала. Оператор select позволяет нам это сделать.

Оператор select выглядит как оператор switch. Каждый case внутри
select содержит канал получения или отправки. select ждет
завершения одного case, а затем запускает его и связанный с
ним оператор case. Как будто select смотрит на оба канала сразу
и действует, когда видит, что что-то случается с любым из них.

В следующем листинге используется time.After для создания канала
тайм-аута, а затем используется select для ожидания каналом
сонных гоферов и тайм-аута канала.
*/

/*
На заметку: Когда в операторе select нет ни одного случая case,
он будет ждать вечно. Это может оказаться полезным для остановки
возвращения функции main, когда вы начинаете горутины, что должны
перестать выполняться на неопределенное время.
Не очень интересно, когда все гоферы спят в точности по три
секунды, потому что терпение всегда заканчивается до момента их
пробуждения. Гоферы в следующем листинге спят случайное количество
времени. При запуске вы увидите, что некоторые гоферы просыпаются
вовремя, а некоторые нет.
Данный паттерн полезен, когда вам нужно ограничить время на
выполнения определенной операции. Поместив действие внутрь
горутины и отправив его каналу, когда тот завершен, можно добиться
фиксированного времени практически для всего в Go.

Хотя мы перестали ждать горутин, если мы не вернулись из функции
main, они все еще будут существовать, занимая память. Если возможно,
лучше завершить их работу.
*/

func init() {
	rand.Seed(time.Now().Unix()) // Настраиваем рандом так, чтобы он был разным для каждого вызова
}

func sleepyGopher(id int, c chan int) {
	duration := time.Duration(rand.Intn(3000)) * time.Millisecond
	fmt.Printf("gopher %d sleep for %v\n", id, duration)
	time.Sleep(duration)
	c <- id
}

func main() {
	timeout := time.After(2 * time.Second)

	c := make(chan int, 5)

	/**
	Горутины для гоферов нужно создать заранее. Если делать это в for вместе с select, то select будет
	блокировать дальнейшее исполнение и создание cледующей горутины
	**/

	for i := 0; i < 5; i++ {
		go sleepyGopher(i, c)
	}

	for i := 0; i < 5; i++ {
		select { // Оператор select
		case gopherID := <-c: // Ждет, когда проснется гофер
			fmt.Println("gopher ", gopherID, " has finished sleeping")
		case <-timeout: // Ждет окончания времени
			fmt.Println("my patience ran out")

			return // Сдается и возвращается
		}
	}
}
