package main

import (
	"fmt"
	"os"
)

/*
Следующий пакет, который мы просто обязаны рассмотреть, это пакет os.
Он содержит огромный набор высокоуровневых инструментов для работы с файлами (и не только).
Для начала мы должны отметить, что рассматриваемый пакет сам не предоставляет
удобных инструментов для чтения и записи в файл, хотя теоретически чтение и запись возможны.
Центром пакета является объект os.File, который реализует ряд интерфейсов,
в т.ч. Reader и Writer. Таким образом для удобной работы с данным типом
нам может потребоваться что-то еще, например для чтения всего файла
может быть использована функция ReadAll из ранее рассмотренного пакета io/ioutil.
Для создания рассматриваемого объекта мы можем использовать ряд предлагаемых пакетом функций:

	func Create(name string) (*File, error) // создание файла с именем name
	func Open(name string) (*File, error) // открытие файла с именем name

Данный объект имеет ряд методов, позволяющих вернуть имя файла,
изменить права доступа или владельца файла. Нас же, прежде всего,
будет интересовать метод Close(), который должен быть вызван при закрытии файла,
чтобы освободить занятые нашей программой ресурсы операционной системы.
Чтобы быть уверенными, что файл будет закрыт, а ресурсы освобождены
даже в случае критической непредвиденной ошибки, рекомендуется сразу после проверки,
что файл создан / открыт запланировать его закрытие
с помощью оператора отложенного вызова defer:

	f, err := os.Open("fileName")
		if err != nil {
			...
		}
	defer f.Close()

С имеющимися методами данного типа вы можете ознакомиться в документации,
примеры же работы с этим объектом мы приведем в следующем шаге,
когда рассмотрим более удобные способы работы с этим типом.
Переименование и удаление файлов делается через функции Rename и Remove:
*/
func main() {

	// создаем файл
	os.Create("text.txt")
	// переименовываем файл
	os.Rename("text.txt", "new_text.txt")
	// удаляем файл
	os.Remove("new_text.txt")
	// кстати, os позволяет работать не только с файлами
	// выходим из программы:
	os.Exit(0)

}

// Так же мы можем получать информацию файлов и сравнивать их:
func test() {
	file1, _ := os.Create("text.txt")
	file2, _ := os.Create("text.txt")
	info1, _ := file1.Stat() // функция Stat возвращает информацию о файле и ошибку
	info2, _ := file2.Stat()
	fmt.Println(os.SameFile(info1, info2)) // true
}

/*
вот что мы можем получить из FileInfo:
A FileInfo describes a file and is returned by Stat and Lstat.
	type FileInfo interface {
		Name() string       // base name of the file
		Size() int64        // length in bytes for regular files; system-dependent for others
		Mode() FileMode     // file mode bits
		ModTime() time.Time // modification time
		IsDir() bool        // abbreviation for Mode().IsDir()
		Sys() interface{}   // underlying data source (can return nil)
	}

Также существует удобная функция WriteString у файлов,
которая записывает строки в конце файла. Например,
нужно открыть существующий файл с какой-то информацией и записать, не затрагивая старую.
*/

func appendString() {
	file1, _ := os.Create("text.txt")
	file1.WriteString("1 строка \n")
	file1.WriteString("2 строка \n")
	file1.Close()
}

// внутри файла будет:
// 1 строка
// 2 строка
