package main

import (
	"fmt"
	"net"
)

/*
Для прослушивания и приемы входящих запросов в пакете net
определена функция net.Listen:

	func Listen(network, laddr string) (net.Listener, error)

Функция принимает два параметра: network - протокол,
по которому приложение будет получать запросы, и laddr представляет
локальный адрес, по которому будет запускаться сервер. Протокол
должен представлять одно из значений: "tcp", "tcp4", "tcp6", "unix",
"unixpacket". Локальный адрес может содержать только номер порта,
например, ":8080". В этом случае приложение будет обслуживать по всем.

В случае успешного выполнения функция возвращает объект интерфейса
net.Listener, который представляет функционал для приема входящих
подключений. В зависимости от типа используемого протокола
возвращаемый объект Listener может представлять тип net.TCPListener
или net.UnixListener (оба этих типа реализуют интерфейс net.Listener).

Основные методы, которые представляет net.Listener:
  - Accept() (принимает входящее подключение)
  - Close() (закрывает подключение).

Вначале в функции net.Listen("tcp", ":4545") устанавливается 4545 порт
для прослушивания подключений по протоколу TCP. После вызова этой функции
сервер запущен и готов принимать подключения. Затем в бесконечном цикле
for получаем входящие подключения с помощью вызова listener.Accept().
Этот метод возвращает объект net.Conn, который представляет подключенного
клиента. Затем мы можем каким-нибудь образом обработать это подключение.
Например, с помощью метода Write отправить ему сообщение. Поскольку
данный метод принимает срез байтов, то любые сообщения надо
транслировать в срез байтов: conn.Write([]byte(message))
*/

func main() {
	message := "Hello, I am a server" // отправляемое сообщение
	listener, err := net.Listen("tcp", ":4545")

	if err != nil {
		fmt.Println(err)
		return
	}
	defer listener.Close()
	fmt.Println("Server is listening...")
	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println(err)
			return
		}
		conn.Write([]byte(message))
		conn.Close()
	}
}
