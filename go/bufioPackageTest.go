package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

/*
В качестве небольшого отступления рассмотрим вопрос о целесообразности использования
того или иного метода чтения / записи. Если объем данных небольшой, то разумно
использовать функции из пакета io/ioutil - они позволяют нам не заботиться
о закрытии файла (кроме функции ReadAll, которая в качестве аргумента получает
тип io.Reader), кроме того, все данные считываются / записываются за раз.
Стоит дополнить, что многие методы io/ioutil это просто удобные обертки (абстракции)
под капотом которых тот же os.OpenFile и тд.
Поэтому если хочется более близкий доступ к системе и возможностям используйте os.

Но что если объем данных велик, или не все данные используются единовременно
(или готовятся к записи постепенно)? Тогда правильно будет отдать предпочтение пакету
bufio, который может считывать данные поэтапно, в т.ч. построчно,
записывать данные постепенно.

Если же данные предоставлены нам в специальном формате: csv, json, xml и пр.,
то правильным будет использовать специальные пакеты Go для работы с такими данными.
Стандартная библиотека Go позволяет читать и записывать данные в различных
структурированных форматах.
*/

/*
Пакет bufio предоставляет нам ряд инструментов для удобного чтения
и записи информации из объектов, удовлетворяющих интерфейсам io.Reader
и io.Writer. Нас в этом вопросе прежде всего будут интересовать типы
bufio.Reader, bufio.Writer и bufio.Scanner. Но перед тем как перейти
к рассмотрению данных типов сделаем одно замечание:
объекты в пакете bufio имеют собственный буфер, позволяющий им
реализовать дополнительные методы по сравнению с интерфейсами
io.Reader и io.Writer, это необходимо учитывать в работе.

bufio.Reader
Данный тип создается с помощью функций:

	func NewReader(rd io.Reader) *Reader // создает Reader со стандартным буфером 4096 байт
	func NewReaderSize(rd io.Reader, size int) *Reader // создает Reader с произвольным буфером

Рассмотрим некоторые из методов bufio.Reader и примеры работы:

	file, err := os.Open("test.txt")
	if err != nil {
		...
	}
	defer file.Close()
*/
func main() {
	file, err := os.Open("test.txt")
	if err != nil {
		panic(err)
	}
	rd := bufio.NewReader(file)

	buf := make([]byte, 10)
	n, err := rd.Read(buf) // читаем в buf 10 байт из ранее открытого файла
	if err != nil && err != io.EOF {
		panic(err)
	}
	fmt.Printf("прочитано %d байт: %s\n", n, buf) // прочитано 10 байт: bufio ...

	s, err := rd.ReadString('\n') // читаем данные до разрыва абзаца ('\n')
	fmt.Printf("%s\n", s)         // ... здесь будет строка
	writer()
}

/*
bufio.Reader позволяет читать данные по байтам, рунам, строкам и пр.,
указывать символ, на котором необходимо прекратить чтение.
Когда данные будут прочитаны до конца, метод вернет ошибку io.EOF.

bufio.Writer
bufio.Writer создан для записи в объекты, удовлетворяющие интерфейсу
io.Writer, но предоставляет ряд более высокоуровневых методов,
в частности метод WriteString(s string):

	file, err := os.Create("test.txt")
	if err != nil {
		...
	}
	defer file.Close()
*/
func writer() {
	file, err := os.Open("test.txt")
	if err != nil {
		panic(err)
	}
	w := bufio.NewWriter(file)
	n, err := w.WriteString("Запишем строку")
	if err != nil {
		panic(err)
	}
	fmt.Printf("Записано %d байт\n", n) // Записано 27 байт

	// bufio.Writer имеет собственный буфер,
	// чтобы быть уверенным, что данные точно записаны,
	// вызываем метод Flush()
	w.Flush()
}

/*
Как вы уже поняли, создается объект функцией NewWriter(w io.Writer).

bufio.Scanner
bufio.Scanner создан для построчного чтения данных.
Создается он функцией NewScanner(r io.Reader),
посмотрим, как работает этот тип:

	file, err := os.Open("test.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()
	s := bufio.NewScanner(file)

Я заранее записал в файл 5 цифр, каждую на новой строке
	for s.Scan() { // возвращает true, пока файл не будет прочитан до конца
		fmt.Printf("%s\n", s.Text()) // s.Text() содержит данные, считанные на данной итерации
	}
*/
// 1
// 2
// 3
// 4
// 5
