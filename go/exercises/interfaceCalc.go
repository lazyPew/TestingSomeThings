package main

import (
	"errors"
	"fmt"
)

// import (
// 	"encoding/json" // пакет используется для проверки ответа, не удаляйте его
// 	"fmt"           // пакет используется для проверки ответа, не удаляйте его
// 	"os"            // пакет используется для проверки ответа, не удаляйте его
// )

/*
Итак, вы получаете 3 значения типа пустой интерфейс: если все удачно,
то первые 2 значения будут float64. Третье значение в идеальном случае будет строкой,
которая может иметь значения: "+", "-", "*", "/" (определенная математическая операция).
Но такие идеальные случаи будут не всегда, вы можете получить значения других типов,
а также строка в третьем значении может не относится к одной из указанных математических операций.

Результат выполнения программы должен быть таков:
    1) 	в штатной ситуации вы должны напечатать в стандартный вывод результат
		выполнения математической операции с точностью до 4 цифры после запятой
		(fmt.Printf(%.4f));
    2) 	если первое или второе значение не является типом float64,
		вы должны напечатать сообщение об ошибке вида:
		'value=полученное_значение: тип_значения' (например: value=true: bool)
    3) 	если третье значение имеет неверный тип или передан знак,
		не относящийся к указанным выше математическим операциям,
		сообщение об ошибке должно иметь вид: 'неизвестная операция'

Гарантируется, что ошибка в аргументах может быть только одна,
поэтому если вы при проверке первого значения увидели, что оно содержит ошибку -
печатайте сообщение об ошибке и завершайте работу программы,
проверка остальных аргументов значения уже не имеет,
а проверяющая система воспримет 2 сообщения об ошибке как нарушение условия выполнения задания.
*/

func doTask(v1, v2 float64, op interface{}) {
	switch op {
	case "-":
		fmt.Printf("%.4f", v1-v2)
	case "+":
		fmt.Printf("%.4f", v1+v2)
	case "*":
		fmt.Printf("%.4f", v1*v2)
	case "/":
		fmt.Printf("%.4f", v1/v2)
	default:
		fmt.Println("неизвестная операция")
	}
}

func checkTypes(v1, v2 interface{}) (float64, float64, error) {
	var v11, v22 float64
	if v, ok := v1.(float64); !ok {
		return v11, v22, errors.New(fmt.Sprintf("value=%v: %T", v1, v1))
	} else {
		v11 = v
	}
	if v, ok := v2.(float64); !ok {
		return v11, v22, errors.New(fmt.Sprintf("value=%v: %T", v2, v2))
	} else {
		v22 = v
	}
	return v11, v22, nil
}

func main() {
	// value1, value2, operation := readTask() // исходные данные получаются с помощью этой функции
	// все полученные значения имеют тип пустого интерфейса
	value1, value2, operation := 2.3588039867109636, true, "-"
	v1, v2, err := checkTypes(value1, value2)
	if err != nil {
		fmt.Println(err.Error())
	} else {
		doTask(v1, v2, operation)
	}
}
